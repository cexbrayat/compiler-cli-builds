{"version":3,"file":"transform.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/factories/src/transform.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {relativePathBetween} from '../../util/src/path';\n\nconst STRIP_NG_FACTORY = /(.*)NgFactory$/;\n\nexport interface FactoryInfo {\n  sourceFilePath: string;\n  moduleSymbolNames: Set<string>;\n}\n\nexport function generatedFactoryTransform(\n    factoryMap: Map<string, FactoryInfo>,\n    coreImportsFrom: ts.SourceFile | null): ts.TransformerFactory<ts.SourceFile> {\n  return (context: ts.TransformationContext): ts.Transformer<ts.SourceFile> => {\n    return (file: ts.SourceFile): ts.SourceFile => {\n      return transformFactorySourceFile(factoryMap, context, coreImportsFrom, file);\n    };\n  };\n}\n\nfunction transformFactorySourceFile(\n    factoryMap: Map<string, FactoryInfo>, context: ts.TransformationContext,\n    coreImportsFrom: ts.SourceFile | null, file: ts.SourceFile): ts.SourceFile {\n  // If this is not a generated file, it won't have factory info associated with it.\n  if (!factoryMap.has(file.fileName)) {\n    // Don't transform non-generated code.\n    return file;\n  }\n\n  const {moduleSymbolNames, sourceFilePath} = factoryMap.get(file.fileName) !;\n\n  const clone = ts.getMutableClone(file);\n\n  const transformedStatements = file.statements.map(stmt => {\n    if (coreImportsFrom !== null && ts.isImportDeclaration(stmt) &&\n        ts.isStringLiteral(stmt.moduleSpecifier) && stmt.moduleSpecifier.text === '@angular/core') {\n      const path = relativePathBetween(sourceFilePath, coreImportsFrom.fileName);\n      if (path !== null) {\n        return ts.updateImportDeclaration(\n            stmt, stmt.decorators, stmt.modifiers, stmt.importClause, ts.createStringLiteral(path));\n      } else {\n        return ts.createNotEmittedStatement(stmt);\n      }\n    } else if (ts.isVariableStatement(stmt) && stmt.declarationList.declarations.length === 1) {\n      const decl = stmt.declarationList.declarations[0];\n      if (ts.isIdentifier(decl.name)) {\n        const match = STRIP_NG_FACTORY.exec(decl.name.text);\n        if (match === null || !moduleSymbolNames.has(match[1])) {\n          // Remove the given factory as it wasn't actually for an NgModule.\n          return ts.createNotEmittedStatement(stmt);\n        }\n      }\n      return stmt;\n    } else {\n      return stmt;\n    }\n  });\n  if (!transformedStatements.some(ts.isVariableStatement)) {\n    // If the resulting file has no factories, include an empty export to\n    // satisfy closure compiler.\n    transformedStatements.push(ts.createVariableStatement(\n        [ts.createModifier(ts.SyntaxKind.ExportKeyword)],\n        ts.createVariableDeclarationList(\n            [ts.createVariableDeclaration('ÉµNonEmptyModule', undefined, ts.createTrue())],\n            ts.NodeFlags.Const)));\n  }\n  clone.statements = ts.createNodeArray(transformedStatements);\n  return clone;\n}\n"]}