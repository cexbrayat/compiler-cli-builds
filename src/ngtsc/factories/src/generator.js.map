{"version":3,"file":"generator.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/factories/src/generator.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;AAEH,6BAA6B;AAC7B,iCAAiC;AAEjC,MAAM,aAAa,GAAG,aAAa,CAAC;AAEpC;;;GAGG;AACH,MAAa,gBAAgB;IAC3B,UAAU,CAAC,QAAuB,EAAE,WAAmB;QACrD,MAAM,oBAAoB,GACtB,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,aAAa,EAAE,EAAE,CAAC,CAAC;QAC7E,8EAA8E;QAC9E,MAAM,WAAW,GAAG,QAAQ;aACH,UAAU;YACX,2CAA2C;aAC1C,MAAM,CAAC,EAAE,CAAC,kBAAkB,CAAC;YAC9B,kDAAkD;aACjD,MAAM,CACH,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,UAAU,KAAK,SAAS;YACrD,IAAI,CAAC,IAAI,KAAK,SAAS,CAAC;YAChC,wBAAwB;aACvB,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,IAAM,CAAC,IAAI,CAAC,CAAC;QAEvD,mFAAmF;QACnF,mFAAmF;QACnF,qCAAqC;QACrC,MAAM,QAAQ,GAAG,WAAW,CAAC,GAAG,CAC5B,IAAI,CAAC,EAAE,CAAC,gBAAgB,IAAI,uCAAuC,IAAI,IAAI,CAAC,CAAC;QACjF,MAAM,UAAU,GAAG;YACjB,0FAA0F;YAC1F,4FAA4F;YAC5F,8FAA8F;YAC9F,mDAAmD;YACnD,sCAAsC;YACtC,WAAW,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,oBAAoB,IAAI;YACpE,GAAG,QAAQ;SACZ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACb,OAAO,EAAE,CAAC,gBAAgB,CACtB,WAAW,EAAE,UAAU,EAAE,QAAQ,CAAC,eAAe,EAAE,IAAI,EAAE,EAAE,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;IACjF,CAAC;IAED,qBAAqB,CAAC,KAA4B;QAChD,MAAM,GAAG,GAAG,IAAI,GAAG,EAAkB,CAAC;QACtC,KAAK,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,UAAU,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;aACpD,OAAO,CAAC,UAAU,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,UAAU,CAAC,OAAO,CAAC,OAAO,EAAE,eAAe,CAAC,EAAE,UAAU,CAAC,CAAC,CAAC;QAC9F,OAAO,GAAG,CAAC;IACb,CAAC;CACF;AAxCD,4CAwCC;AAED,SAAS,UAAU,CAAC,IAAoB;IACtC,OAAO,IAAI,CAAC,SAAS,KAAK,SAAS;QAC/B,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,IAAI,EAAE,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;AAC1E,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as path from 'path';\nimport * as ts from 'typescript';\n\nconst TS_DTS_SUFFIX = /(\\.d)?\\.ts$/;\n\n/**\n * Generates ts.SourceFiles which contain variable declarations for NgFactories for every exported\n * class of an input ts.SourceFile.\n */\nexport class FactoryGenerator {\n  factoryFor(original: ts.SourceFile, genFilePath: string): ts.SourceFile {\n    const relativePathToSource =\n        './' + path.posix.basename(original.fileName).replace(TS_DTS_SUFFIX, '');\n    // Collect a list of classes that need to have factory types emitted for them.\n    const symbolNames = original\n                            .statements\n                            // Pick out top level class declarations...\n                            .filter(ts.isClassDeclaration)\n                            // which are named, exported, and have decorators.\n                            .filter(\n                                decl => isExported(decl) && decl.decorators !== undefined &&\n                                    decl.name !== undefined)\n                            // Grab the symbol name.\n                            .map(decl => decl.name !.text);\n\n    // For each symbol name, generate a constant export of the corresponding NgFactory.\n    // This will encompass a lot of symbols which don't need factories, but that's okay\n    // because it won't miss any that do.\n    const varLines = symbolNames.map(\n        name => `export const ${name}NgFactory = new i0.ÉµNgModuleFactory(${name});`);\n    const sourceText = [\n      // This might be incorrect if the current package being compiled is Angular core, but it's\n      // okay to leave in at type checking time. TypeScript can handle this reference via its path\n      // mapping, but downstream bundlers can't. If the current package is core itself, this will be\n      // replaced in the factory transformer before emit.\n      `import * as i0 from '@angular/core';`,\n      `import {${symbolNames.join(', ')}} from '${relativePathToSource}';`,\n      ...varLines,\n    ].join('\\n');\n    return ts.createSourceFile(\n        genFilePath, sourceText, original.languageVersion, true, ts.ScriptKind.TS);\n  }\n\n  computeFactoryFileMap(files: ReadonlyArray<string>): Map<string, string> {\n    const map = new Map<string, string>();\n    files.filter(sourceFile => !sourceFile.endsWith('.d.ts'))\n        .forEach(sourceFile => map.set(sourceFile.replace(/\\.ts$/, '.ngfactory.ts'), sourceFile));\n    return map;\n  }\n}\n\nfunction isExported(decl: ts.Declaration): boolean {\n  return decl.modifiers !== undefined &&\n      decl.modifiers.some(mod => mod.kind == ts.SyntaxKind.ExportKeyword);\n}\n"]}