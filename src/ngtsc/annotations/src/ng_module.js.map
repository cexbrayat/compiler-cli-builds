{"version":3,"file":"ng_module.js","sourceRoot":"","sources":["../../../../../../../packages/compiler-cli/src/ngtsc/annotations/src/ng_module.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ConstantPool, Expression, LiteralArrayExpr, R3DirectiveMetadata, R3InjectorMetadata, R3NgModuleMetadata, WrappedNodeExpr, compileInjector, compileNgModule, makeBindingParser, parseTemplate} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {ErrorCode, FatalDiagnosticError} from '../../diagnostics';\nimport {Decorator, ReflectionHost} from '../../host';\nimport {Reference, ResolvedValue, reflectObjectLiteral, staticallyResolve} from '../../metadata';\nimport {AnalysisOutput, CompileResult, DecoratorHandler} from '../../transform';\n\nimport {SelectorScopeRegistry} from './selector_scope';\nimport {getConstructorDependencies, isAngularCore, toR3Reference, unwrapExpression} from './util';\n\nexport interface NgModuleAnalysis {\n  ngModuleDef: R3NgModuleMetadata;\n  ngInjectorDef: R3InjectorMetadata;\n}\n\n/**\n * Compiles @NgModule annotations to ngModuleDef fields.\n *\n * TODO(alxhub): handle injector side of things as well.\n */\nexport class NgModuleDecoratorHandler implements DecoratorHandler<NgModuleAnalysis, Decorator> {\n  constructor(\n      private checker: ts.TypeChecker, private reflector: ReflectionHost,\n      private scopeRegistry: SelectorScopeRegistry, private isCore: boolean) {}\n\n  detect(node: ts.Declaration, decorators: Decorator[]|null): Decorator|undefined {\n    if (!decorators) {\n      return undefined;\n    }\n    return decorators.find(\n        decorator => decorator.name === 'NgModule' && (this.isCore || isAngularCore(decorator)));\n  }\n\n  analyze(node: ts.ClassDeclaration, decorator: Decorator): AnalysisOutput<NgModuleAnalysis> {\n    if (decorator.args === null || decorator.args.length > 1) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_ARITY_WRONG, decorator.node,\n          `Incorrect number of arguments to @NgModule decorator`);\n    }\n\n    // @NgModule can be invoked without arguments. In case it is, pretend as if a blank object\n    // literal was specified. This simplifies the code below.\n    const meta = decorator.args.length === 1 ? unwrapExpression(decorator.args[0]) :\n                                               ts.createObjectLiteral([]);\n\n    if (!ts.isObjectLiteralExpression(meta)) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta,\n          '@NgModule argument must be an object literal');\n    }\n    const ngModule = reflectObjectLiteral(meta);\n\n    if (ngModule.has('jit')) {\n      // The only allowed value is true, so there's no need to expand further.\n      return {};\n    }\n\n    // Extract the module declarations, imports, and exports.\n    let declarations: Reference[] = [];\n    if (ngModule.has('declarations')) {\n      const expr = ngModule.get('declarations') !;\n      const declarationMeta = staticallyResolve(expr, this.reflector, this.checker);\n      declarations = this.resolveTypeList(expr, declarationMeta, 'declarations');\n    }\n    let imports: Reference[] = [];\n    if (ngModule.has('imports')) {\n      const expr = ngModule.get('imports') !;\n      const importsMeta = staticallyResolve(\n          expr, this.reflector, this.checker,\n          ref => this._extractModuleFromModuleWithProvidersFn(ref.node));\n      imports = this.resolveTypeList(expr, importsMeta, 'imports');\n    }\n    let exports: Reference[] = [];\n    if (ngModule.has('exports')) {\n      const expr = ngModule.get('exports') !;\n      const exportsMeta = staticallyResolve(\n          expr, this.reflector, this.checker,\n          ref => this._extractModuleFromModuleWithProvidersFn(ref.node));\n      exports = this.resolveTypeList(expr, exportsMeta, 'exports');\n    }\n\n    // Register this module's information with the SelectorScopeRegistry. This ensures that during\n    // the compile() phase, the module's metadata is available for selector scope computation.\n    this.scopeRegistry.registerModule(node, {declarations, imports, exports});\n\n    const context = node.getSourceFile();\n\n    const ngModuleDef: R3NgModuleMetadata = {\n      type: new WrappedNodeExpr(node.name !),\n      bootstrap: [],\n      declarations: declarations.map(decl => toR3Reference(decl, context)),\n      exports: exports.map(exp => toR3Reference(exp, context)),\n      imports: imports.map(imp => toR3Reference(imp, context)),\n      emitInline: false,\n    };\n\n    const providers: Expression = ngModule.has('providers') ?\n        new WrappedNodeExpr(ngModule.get('providers') !) :\n        new LiteralArrayExpr([]);\n\n    const injectorImports: WrappedNodeExpr<ts.Expression>[] = [];\n    if (ngModule.has('imports')) {\n      injectorImports.push(new WrappedNodeExpr(ngModule.get('imports') !));\n    }\n    if (ngModule.has('exports')) {\n      injectorImports.push(new WrappedNodeExpr(ngModule.get('exports') !));\n    }\n\n    const ngInjectorDef: R3InjectorMetadata = {\n      name: node.name !.text,\n      type: new WrappedNodeExpr(node.name !),\n      deps: getConstructorDependencies(node, this.reflector, this.isCore), providers,\n      imports: new LiteralArrayExpr(injectorImports),\n    };\n\n    return {\n      analysis: {\n          ngModuleDef, ngInjectorDef,\n      },\n      factorySymbolName: node.name !== undefined ? node.name.text : undefined,\n    };\n  }\n\n  compile(node: ts.ClassDeclaration, analysis: NgModuleAnalysis): CompileResult[] {\n    const ngInjectorDef = compileInjector(analysis.ngInjectorDef);\n    const ngModuleDef = compileNgModule(analysis.ngModuleDef);\n    return [\n      {\n        name: 'ngModuleDef',\n        initializer: ngModuleDef.expression,\n        statements: [],\n        type: ngModuleDef.type,\n      },\n      {\n        name: 'ngInjectorDef',\n        initializer: ngInjectorDef.expression,\n        statements: [],\n        type: ngInjectorDef.type,\n      },\n    ];\n  }\n\n  /**\n   * Given a `FunctionDeclaration` or `MethodDeclaration`, check if it is typed as a\n   * `ModuleWithProviders` and return an expression referencing the module if available.\n   */\n  private _extractModuleFromModuleWithProvidersFn(node: ts.FunctionDeclaration|\n                                                  ts.MethodDeclaration): ts.Expression|null {\n    const type = node.type;\n    // Examine the type of the function to see if it's a ModuleWithProviders reference.\n    if (type === undefined || !ts.isTypeReferenceNode(type) || !ts.isIdentifier(type.typeName)) {\n      return null;\n    }\n\n    // Look at the type itself to see where it comes from.\n    const id = this.reflector.getImportOfIdentifier(type.typeName);\n\n    // If it's not named ModuleWithProviders, bail.\n    if (id === null || id.name !== 'ModuleWithProviders') {\n      return null;\n    }\n\n    // If it's not from @angular/core, bail.\n    if (!this.isCore && id.from !== '@angular/core') {\n      return null;\n    }\n\n    // If there's no type parameter specified, bail.\n    if (type.typeArguments === undefined || type.typeArguments.length !== 1) {\n      return null;\n    }\n\n    const arg = type.typeArguments[0];\n\n    // If the argument isn't an Identifier, bail.\n    if (!ts.isTypeReferenceNode(arg) || !ts.isIdentifier(arg.typeName)) {\n      return null;\n    }\n\n    return arg.typeName;\n  }\n\n  /**\n   * Compute a list of `Reference`s from a resolved metadata value.\n   */\n  private resolveTypeList(expr: ts.Node, resolvedList: ResolvedValue, name: string): Reference[] {\n    const refList: Reference[] = [];\n    if (!Array.isArray(resolvedList)) {\n      throw new FatalDiagnosticError(\n          ErrorCode.VALUE_HAS_WRONG_TYPE, expr, `Expected array when reading property ${name}`);\n    }\n\n    resolvedList.forEach((entry, idx) => {\n      // Unwrap ModuleWithProviders for modules that are locally declared (and thus static\n      // resolution was able to descend into the function and return an object literal, a Map).\n      if (entry instanceof Map && entry.has('ngModule')) {\n        entry = entry.get('ngModule') !;\n      }\n\n      if (Array.isArray(entry)) {\n        // Recurse into nested arrays.\n        refList.push(...this.resolveTypeList(expr, entry, name));\n      } else if (entry instanceof Reference) {\n        if (!entry.expressable) {\n          throw new FatalDiagnosticError(\n              ErrorCode.VALUE_HAS_WRONG_TYPE, expr, `One entry in ${name} is not a type`);\n        } else if (!this.reflector.isClass(entry.node)) {\n          throw new FatalDiagnosticError(\n              ErrorCode.VALUE_HAS_WRONG_TYPE, entry.node,\n              `Entry is not a type, but is used as such in ${name} array`);\n        }\n        refList.push(entry);\n      } else {\n        // TODO(alxhub): expand ModuleWithProviders.\n        throw new Error(`Value at position ${idx} in ${name} array is not a reference: ${entry}`);\n      }\n    });\n\n    return refList;\n  }\n}\n"]}